/**
 * @author      <a href="mailto:michele.lora@univr.it">Michele Lora</a>
 * @date        2015-2016
 * @copyright   Copyright (c) 2015-2017 by University of California, Berkeley.\n
 *              Copyright (c) 2015-2017 by University of Verona.\n
 *              Copyright (c) 2015-2017 by International Business Machines Corporation.\n
 *              Copyright (c) 2016-2017 by University of Southern California.\n
 *              All rights reserved.\n
 *              This project is released under the 3-Clause BSD License.
 *
 * @file	frontend/include/Patterns2Chase/EPSPatterns/HighLevelEPSPatterns.hh
 * @brief
 */



#ifndef EPS_HIGH_LEVEL_PATTERNS
#define EPS_HIGH_LEVEL_PATTERNS

#include "Specification/TextBasedPattern.hh"
#include "EPS/EPSTopology.hh"

#include "Behaviors/Logics/Logics.hh"

#include "Utilities/Graphs/Graphs.hh"

#include <iostream>
#include <vector>

namespace Specification
{

    namespace EPSPatterns
    {

        ///
        /// @brief Base class for the higher level patterns for the EPS System
        /// it adds the possibility to set the Topology of the EPS generated by
        /// ArchEx.
        class HighLevelEPSPattern : public Specification::TextBasedPattern
        {
            public:
                HighLevelEPSPattern( std::regex _regex ) :
                    Specification::TextBasedPattern( _regex ){}

                void 
                    setTopology( chase::epstool::EPS::EPSTopology * topology );

                std::vector< Behaviors::Logics::WellFormedFormula * >
                    createPathFormulae( 
                            Contracts::AGContract * contract,
                            std::vector< std::string > strings );

                ///
                /// @brief Support function that, given a type of nodes and
                /// a topology, retrieves the index of the nodes belonging to
                /// the given type.
                static std::vector< int > * _getNodesByType(
                        std::string type,
                        chase::epstool::EPS::EPSTopology * topology );

                static Behaviors::Logics::WellFormedFormula * 
                    pathDoesNotExist( 
                            std::vector<int> * nodes,
                            chase::epstool::EPS::EPSTopology * topology,
                            bool withNodes = false,
                            bool intention = false );

                static Behaviors::Logics::WellFormedFormula * 
                    pathDoesExist( 
                            std::vector<int> * nodes,
                            chase::epstool::EPS::EPSTopology * topology,
                            bool withNodes = false,
                            bool intention = false );

                static Behaviors::Logics::WellFormedFormula * 
                    _disconnectNode( 
                            int node,
                            chase::epstool::EPS::EPSTopology * topology );

                static void getSubsetBySize( 
                        std::vector< int > nodes,
                        int size,
                        int left,
                        int index,
                        std::vector< int > &combination,
                        std::list< std::vector<int> > &results );

                static std::vector< Behaviors::Logics::WellFormedFormula * > 
                    _waitDisconnection( 
                            int node,
                            chase::epstool::EPS::EPSTopology * topology );




            protected:
                chase::epstool::EPS::EPSTopology * _topology;

                virtual std::vector<std::string> _extractFormulae(
                        std::string text ) = 0;

                virtual void _createConstraints(
                        Contracts::AGContract * contract,
                        std::vector<
                        Behaviors::Logics::WellFormedFormula * > formulae ) = 0;

                virtual std::vector< Behaviors::Logics::WellFormedFormula * >
                    _createPathFormulae( 
                            Contracts::AGContract * contract,
                            std::vector< std::string > strings ) = 0;


        };


        ///
        /// @brief Class for the pattern stating that no elements of a type
        /// has a parallel flow of current. 
        /// The syntax is: "TYPE1,TYPE2,...,TYPEn are never connected in 
        /// parallel through TYPEn+1,...,TYPEn+m"
        //
        /// Where TYPEx is a type of components of the EPS.
        //
        /// \todo To implement this, the best thing seems to extract the "submatrix"
        /// of the AC Part and find the paths between generators.
        class NoParallel : public HighLevelEPSPattern
        {
            public:
                NoParallel( std::regex _regex ) :
                    HighLevelEPSPattern( _regex ){}

            private:

                std::vector<std::string> _extractFormulae(
                        std::string text );

                void _createConstraints(
                        Contracts::AGContract * contract,
                        std::vector<
                        Behaviors::Logics::WellFormedFormula * > formulae );

                std::vector< Behaviors::Logics::WellFormedFormula * > 
                    _createPathFormulae(  
                            Contracts::AGContract * contract,
                            std::vector< std::string > strings );

        };


        ///
        /// @brief Class for pattern stating that whenever an element of a 
        /// certain type becomes unhealthy, it should be disconnected by
        /// the network.
        /// The Syntax is "TYPE must be disconnected when unhealthy"
        ///
        /// To be implemented in LTL, given the variable H, indicating the
        /// healthyness of a component, and the set of contactors c1,..,cn
        /// placed in the input or output edges of the node.
        /// [](~H->X(~c1 & ... & ~cn))
        class UnhealthySources : public HighLevelEPSPattern
        {
            public:
                UnhealthySources( std::regex _regex ) :
                    HighLevelEPSPattern( _regex ){}

            private:

                std::vector<std::string> _extractFormulae(
                        std::string text );

                void _createConstraints(
                        Contracts::AGContract * contract,
                        std::vector<
                        Behaviors::Logics::WellFormedFormula * > formulae );

                std::vector< Behaviors::Logics::WellFormedFormula * > 
                    _createPathFormulae(  
                            Contracts::AGContract * contract,
                            std::vector< std::string > strings );


        };

        ///
        /// @brief Class for pattern stating that whenever an element of a 
        /// certain type becomes unhealthy, it should be disconnected by
        /// the network.
        /// The Syntax is "TYPE must be disconnected when unhealthy"
        ///
        /// To be implemented in LTL, given the variable H, indicating the
        /// healthyness of a component, and the set of contactors c1,..,cn
        /// placed in the input or output edges of the node.
        /// [](~H->X(~c1 & ... & ~cn))
        class UnhealthySourcesStrong : public HighLevelEPSPattern
        {
            public:
                UnhealthySourcesStrong( std::regex _regex ) :
                    HighLevelEPSPattern( _regex ){}

            private:

                std::vector<std::string> _extractFormulae(
                        std::string text );

                void _createConstraints(
                        Contracts::AGContract * contract,
                        std::vector<
                        Behaviors::Logics::WellFormedFormula * > formulae );

                std::vector< Behaviors::Logics::WellFormedFormula * > 
                    _createPathFormulae(  
                            Contracts::AGContract * contract,
                            std::vector< std::string > strings );


        };


        ///
        /// @brief Class for pattern used to state that every component
        /// of a certain type should never be disconnected to every compenents
        /// of another type for more than a time step.
        /// The syntax is "TYPE1 must never be disconnected from TYPE2"
        /// 
        /// Its LTL implementation must use the paths.
        /// []( ~min(paths) -> X( min(path) ))
        /// Where min(paths) is the disjunction of all the possible types.
        class KeepConnected : public HighLevelEPSPattern
        {
            public:
                KeepConnected( std::regex _regex ) :
                    HighLevelEPSPattern( _regex ){}

            private:

                std::vector<std::string> _extractFormulae(
                        std::string text );

                void _createConstraints(
                        Contracts::AGContract * contract,
                        std::vector<
                        Behaviors::Logics::WellFormedFormula * > formulae );

                std::vector< Behaviors::Logics::WellFormedFormula * > 
                    _createPathFormulae(  
                            Contracts::AGContract * contract,
                            std::vector< std::string > strings );


        };



        class KeepPowered : public HighLevelEPSPattern
        {
            public:
                KeepPowered( std::regex _regex ) :
                    HighLevelEPSPattern( _regex ){}

            private:

                std::vector<std::string> _extractFormulae(
                        std::string text );

                void _createConstraints(
                        Contracts::AGContract * contract,
                        std::vector<
                        Behaviors::Logics::WellFormedFormula * > formulae );

                std::vector< Behaviors::Logics::WellFormedFormula * > 
                    _createPathFormulae(  
                            Contracts::AGContract * contract,
                            std::vector< std::string > strings );


        };


        ///
        /// @brief Class for pattern used to state that every component of
        /// a certain type (usually a Load) of a particular side of the net
        /// is connected (powered) by a chain using components of the
        /// same side.
        /// Syntax: "TYPE1 should be powered by TYPE2"
        /// Its LTL implementation will be based on the paths using
        /// components on the same side. 
        class KeepBalanced : public HighLevelEPSPattern
        {
            public:
                KeepBalanced( std::regex _regex ) :
                    HighLevelEPSPattern( _regex ){}

            private:

                std::vector<std::string> _extractFormulae(
                        std::string text );

                void _createConstraints(
                        Contracts::AGContract * contract,
                        std::vector< 
                        Behaviors::Logics::WellFormedFormula * > formulae );

                std::vector< Behaviors::Logics::WellFormedFormula * >
                    _createPathFormulae(  
                            Contracts::AGContract * contract,
                            std::vector< std::string > strings );


        };



        //
        //----- ASSUMPTIONS PATTERNS
        //

        ///
        /// @brief Class for pattern used to specify how many failures are 
        /// allowed among the components of a particular type.
        /// The Syntax is: "N failures are allowed for the TYPE"
        /// Where N is an natural number, while TYPE is a sub-set of 
        /// the components
        class AllowedFailures : public HighLevelEPSPattern
        {
            public:
                AllowedFailures( std::regex _regex ) :
                    HighLevelEPSPattern( _regex ){};

            private:

                std::vector<std::string> _extractFormulae(
                        std::string text );

                void _createConstraints(
                        Contracts::AGContract * contract,
                        std::vector< 
                        Behaviors::Logics::WellFormedFormula * > formulae );

                std::vector< Behaviors::Logics::WellFormedFormula * >
                    _createPathFormulae(  
                            Contracts::AGContract * contract,
                            std::vector< std::string > strings );

        };

        ///
        /// @brief Class for the pattern used to specify which components
        /// cannot fail. It is a special case of the AllowedFailures Pattern,
        /// and it is implemented in the same source file:
        ///
        /// src/Patterns2Chase/EPSPatterns/AllowedFailures.cc
        ///
        /// It specify that for a particular type of components, no failures
        /// are allowed.
        /// Syntax: "TYPE are never failing"
        /// Where TYPE is a sub-set of the nodes in the topology.
        class NoFailuresAllowed : public AllowedFailures
        {
            public:
                NoFailuresAllowed( std::regex _regex ) :
                    AllowedFailures( _regex ){};

            private:

                std::vector< std::string > _extractFormulae( std::string text );

        };

        ///
        /// @brief Class for the pattern stating that the components of a
        /// particular type, whenever they fail they fail for good.
        ///
        /// Syntax: "TYPE do not recover after failures"
        /// Where TYPE is a sub-set of the nodes in the topology.
        class PermanentFailures : public HighLevelEPSPattern
        {
            public:
                PermanentFailures( std::regex _regex) :
                    HighLevelEPSPattern( _regex ){};

            private:

                std::vector<std::string> _extractFormulae(
                        std::string text );

                void _createConstraints(
                        Contracts::AGContract * contract,
                        std::vector< 
                        Behaviors::Logics::WellFormedFormula * > formulae );

                std::vector< Behaviors::Logics::WellFormedFormula * >
                    _createPathFormulae(  
                            Contracts::AGContract * contract,
                            std::vector< std::string > strings );


        };
       

    }
}


#endif // EPS_HIGH_LEVEL_PATTERNS
