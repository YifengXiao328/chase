% \documentclass{sig-alternate-mod}
% \documentclass[10pt,final,journal,twocolumn]{IEEEtran}
\documentclass[journal]{IEEEtran}

\usepackage[obeyspaces]{url}  

\usepackage{cite}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{amsmath} 
\usepackage{amsfonts}
\usepackage{listings}
\usepackage{color}

\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{enumitem}
% \usepackage{hyperref} 
% \usepackage{algorithm2e}

\RequirePackage{ifthen}
\usepackage{amssymb,mathrsfs,wasysym,amsthm}
\usepackage[mathscr]{euscript}
\usepackage{tikz}
\usetikzlibrary{shadows}
\usetikzlibrary{shapes}
%
\newcommand{\always}{\square}
\newcommand{\eventually}{\Diamond}
\renewcommand{\next}{\ocircle}
\newcommand{\until}{\hspace{1mm}\mathcal{U}\hspace{1mm}}
\newcommand{\untilc}{\mathcal{U}}
\newcommand{\release}{\hspace{1mm}\mathcal{R}\hspace{1mm}}
\newcommand{\true}{\relax\ifmmode \mathit{True} \else \em True \/\fi}
\newcommand{\false}{\relax\ifmmode \mathit{False} \else \em False \/\fi}
\newcommand{\aand}{\hspace{1mm}\wedge\hspace{1mm}}
\newcommand{\oor}{\hspace{1mm}\vee\hspace{1mm}}
\newcommand{\set}[1]{\left\{#1\right\}}

\lstset{ %
basicstyle=\scriptsize,       % the size of the fonts that are used for the code
showspaces=false,               % show spaces adding particular underscores
showstringspaces=true,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
frame=single,           % adds a frame around the code
tabsize=2,          % sets default tabsize to 2 spaces
captionpos=b,           % sets the caption-position to bottom
breaklines=true,        % sets automatic line breaking
breakatwhitespace=true,    % sets if automatic breaks should only happen at whitespace
escapeinside={\%*}{*)}          % if you want to add a comment within your code
}

% \newenvironment{comment}
% {\rule{1ex}{1ex} %\hspace{\stretch{1}}
%  \bfseries \small}
% {\hspace{\stretch{1}}%
% \rule{1ex}{1ex}}

% commands to format vectors and matrices
\renewcommand{\vec}[1]{\mbox{\boldmath{$#1$}}}
\newcommand{\mat}[1]{\mathbf{#1}}
\newcommand{\pfr}[1]{\mathcal{#1}}
\newcommand{\pfc}[1]{\mathscr{#1}}
\newcommand{\pfv}[1]{#1}
\newcommand{\rr}{\mathbb{R}}
\newcommand{\bb}{\mathbb{B}}
\newcommand{\nn}{\mathbb{N}}
\newcommand{\TT}{\mathbb{T}}

% command to format some mathematical symbols
\newcommand{\dif}{\mathrm{d}}
\newcommand{\myexp}{\mathrm{e}}
\newcommand{\net}[1]{\textcircled{\footnotesize #1}}

\graphicspath{{./eps/}}
\DeclareGraphicsExtensions{.eps}
\newenvironment{tabrow}[1]{\ \\ \noindent \begin{tabular*}{\textwidth}{p{4ex}{\textwidth}} \midrule \multicolumn{2}{l}{#1} \\ & \noindent }{ \\ \end{tabular*} }
\newenvironment{footnotesizegrammar}{ \begin{footnotesize} \begin{grammar} }{ \end{grammar} \end{footnotesize} }

\usepackage{epstopdf}

\newcommand{\myimg}[3]{\includegraphics[width=#2, height=#3]{#1}}
\newcommand{\mycomb}[3]{\resizebox{#2}{#3}{\input{eps/#1.pstex_t}}}

\newcommand{\figref}[1]{{Fig.~\ref{fig:#1}}}
\newcommand{\tabref}[1]{Table \mbox{\ref{tab:#1}}}
\newcommand{\seclabel}[1]{\label{sec:#1}}
\newcommand{\figlabel}[1]{\label{fig:#1}}
\newcommand{\secref}[1]{\mbox{Section{ }\ref{sec:#1}}}
\newcommand{\lemmaref}[1]{\mbox{Lemma{ }\ref{#1}}}
\newcommand{\theref}[1]{\mbox{Theorem{ }\ref{#1}}}
\newcommand{\noop}[1]{}

\newtheorem{theorem}{\bf Theorem}[section]
\newtheorem{lemma}[theorem]{\bf Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{example}{Example}
\newtheorem{conjecture}{Conjecture}
\newtheorem{remark}{Remark}

\def\P{{\mathbb P}}        % probability
\def\E{{\mathbb E}}        % expectation
\def\1{{\mathbf 1}}        % indicator
\def\var{{\mathop{\mathbf Var}}}    % variance
\def\cov{{\mathop{\mathbf Cov}}}    % covariance
\def  \iff      {\text{iff}}
\def  \qmodels  {\models \!\!\!\! ? \ \ }
\def  \nmodels  {\models \!\!\!\!\!\! / \ \ }
\def  \aand       {\text{and}}
\def  \st       {\text{s.t.}}

\newcommand{\pierluigi}[1]{{\normalsize{{{\color{blue}(PN:\ #1)}}}}}
% \newcommand{\alberto}[1]{{\normalsize{{{\color{green}(ASV:\ #1)}}}}}
\newcommand{\michele}[1]{{\normalsize{{{\color{red}(ML:\ #1)}}}}}
\newcommand{\verswitch}[2]{#1} % SHORT/PAPER version
% \newcommand{\verswitch}[2]{#2} % LONG/REPORT version


\begin{document}

\title{CHASE: List of Supported Patterns
% \titlenote{(Does NOT produce the permission block,
 %copyright information nor page numbering). For use with
 %ACM\_PROC\_ARTICLE-SP.CLS. Supported by ACM.}
}
% \subtitle{[Extended Abstract] \titlenote{A full version of
% this paper is available as \textit{Author's Guide to
% Preparing ACM SIG Proceedings Using \LaTeX$2_\epsilon$\
% and
%  BibTeX} at
% \texttt{www.acm.org/eaddress.htm}}}
%
% \numberofauthors{8}
% \author{
% % 1st. author
% \alignauthor
% Ben Trovato\titlenote{Dr.~Trovato insisted his name be first.}\\
%        \affaddr{Institute for Clarity in Documentation}\\
%        \affaddr{1932 Wallamaloo Lane}\\
%        \affaddr{Wallamaloo, New Zealand}\\
%        \email{trovato@corporation.com}
% % 2nd. author
% \alignauthor
% G.K.M. Tobin\titlenote{The secretary disavows
% any knowledge of this author's actions.}\\
%        \affaddr{Institute for Clarity in Documentation}\\
%        \affaddr{P.O. Box 1212}\\
%        \affaddr{Dublin, Ohio 43017-6221}\\
%        \email{webmaster@marysville-ohio.com}
% % 3rd. author
% \alignauthor Lars Th{\o}rv{\"a}ld\titlenote{This author is the
% one who did all the really hard work.}\\
%        \affaddr{The Th{\o}rv{\"a}ld Group}\\
%        \affaddr{1 Th{\o}rv{\"a}ld Circle}\\
%        \affaddr{Hekla, Iceland}\\
%        \email{larst@affiliation.org}
% \and  % use '\and' if you need 'another row' of author names
% % 4th. author
% \alignauthor Lawrence P. Leipuner\\
%        \affaddr{Brookhaven Laboratories}\\
%        \affaddr{Brookhaven National Lab}\\
%        \affaddr{P.O. Box 5000}\\
%        \email{lleipuner@researchlabs.org}
% % 5th. author
% \alignauthor Sean Fogarty\\
%        \affaddr{NASA Ames Research Center}\\
%        \affaddr{Moffett Field}\\
%        \affaddr{California 94035}\\
%        \email{fogartys@amesres.org}
% % 6th. author
% \alignauthor Charles Palmer\\
%        \affaddr{Palmer Research Laboratories}\\
%        \affaddr{8600 Datapoint Drive}\\
%        \affaddr{San Antonio, Texas 78229}\\
%        \email{cpalmer@prl.com}
% }
% \additionalauthors{Additional authors: John Smith (The Th{\o}rv{\"a}ld Group,
% email: {\texttt{jsmith@affiliation.org}}) and Julius P.~Kumquat
% (The Kumquat Consortium, email: {\texttt{jpkumquat@consortium.net}}).}
% \date{30 July 1999}
%
% \numberofauthors{1}
% \author{}
% \author{
% \alignauthor Pierluigi Nuzzo$^{\S}$\hspace{0.5in} Huan Xu$^{\dag}$\hspace{0.5in} Necmiye Ozay$^{\dag}$ \\
% John B. Finn$^{\S}$\hspace{0.2in} Alberto L. Sangiovanni-Vincentelli$^{\S}$\hspace{0.2in}
% Richard M. Murray$^{\dag}$\\ Alexandre Donz{\'e}$^{\S}$\hspace{0.5in} Sanjit A. Seshia$^{\S}$
% \vspace{10pt}
% \email{
%  	$^{\S}$EECS Department, University of California at
%  	Berkeley, Berkeley, CA\\
% 	$^{\dag}$Engineering and Applied Science, California Institute of Technology, Pasadena, CA }\\
% }

\author{Pierluigi~Nuzzo and Michele~Lora% <-this % stops a space
\thanks{P.~Nuzzo is with the University of California at Berkeley, Department of
Electrical Engineering and Computer Sciences,
Cory Hall 1770, Berkeley, CA 94720. E-mail:
nuzzo@eecs.berkeley.edu.}%
\thanks{M.~Lora is with the University of Verona, Verona, Italy.}
}

\maketitle

\begin{abstract}
This document lists the patterns currently supported by CHASE and their translation in linear temporal logic. 
\end{abstract}

% A category with the (minimum) three required fields
% \category{H.4}{Information Systems
% Applications}{Miscellaneous}
% \category{}{}{}
% A category including the fourth, optional field follows...
% \category{D.2.8}{Software Engineering}{Metrics}[complexity
% measures, performance measures]

% \terms{Theory}
% \terms{}
% \keywords{ACM proceedings, \LaTeX, text tagging} % NOT
% required for Proceedings
% \keywords{}

\section{System Topology, Components, and Variables}\label{sec:variables}

In what follows, we refer to a system \emph{topology} represented as a graph $\pfr{G}=(V,E)$, 
where both nodes and edges are associated to system components, i.e., $C = V \cup E$. 
% can be generated from a visual representation of the topology, provided by the user,
% or directly imported as a result of an optimization procedure. 
We consider the case of a power distribution network to define an initial set of 
\emph{patterns}, i.e.,  a set of pre-defined
primitives that can be 
used to specify system requirements and enable automatic generation of Linear Temporal Logic (LTL) specifications. The proposed case study is supported by the examples in the first release of CHASE. The patterns can, however, be extended to support generic networked systems. 

In a power system, the set of nodes $V$ 
% $V = \{v_1, v_2, \ldots, v_n\}$
can be used to represent the set of power components, e.g., generators, buses, and rectifier
units; the set of edges $E$
% $E = \{e_1, e_2, \ldots, e_m\}$
can be used to represent the set of contactors (switches), which are responsible for an interconnection between power components, as well as solid wire links between components. Nodes are labelled based on their \emph{type}, e.g., generators, buses, loads. 
The topology graph is also associated with an adjacency matrix $\textbf{A}$, which is a square matrix whose diagonal entries are
zeros, and whose non-diagonal entries are zero or non-zero depending on whether a
connection (with or without contactors) exists between vertices. 
% Each contactor is marked by an index an integer number   

\textit{Environment} variables include the health statuses of node components in $V$, which 
are uncontrolled. They can each take values of healthy
(1) and unhealthy (0), and may change at any point in time.
\textit{Controlled} variables are, instead, associated with the edge components (contactors), and can each take values of open
(0) or closed (1). In a power system, a closed contactor allows power to pass through, while an
open one does not.

Requirements can also be attached to some of the components, such as buses and loads, to specify whether they are powered or unpowered. This status depends on the status of their neighboring
contactors and all the node and edge components that connect the bus or load to a healthy power source. 
% To capture this kind of requirements, we reason about paths in the topology graph. Specifically, we denote as \emph{interconnection path} $\tilde{p}_{i,j}$ a path between nodes (components) $V_i$ and $V_j$ such that all the edge variables (contactors) evaluate to 1 (i.e., contactors are closed) along the path. If also the node variables along the path evaluate to 1 (i.e., components are healthy), then we also say that the interconnection path is a \emph{live path} and denote it as $p_{i,j}$. 
To capture this kind of requirements, we reason about paths in the topology graph. Specifically, we denote as \emph{interconnection path} a path $p_{i,j}$ between nodes (components) $V_i$ and $V_j$ such that all the edge variables (contactors) along the path evaluate to 1 (i.e., contactors are closed). If also the node variables along the path evaluate to 1 (i.e., components are healthy), then we also say that the interconnection path is a \emph{live path}. In the following, we denote components by uppercase letters (e.g., $E$, $V$) and component status variables by lowercase letters (e.g., $e$, $v$). Moreover, we call a \emph{variable path} $\tilde{p}_{i,j}$ the set of node and edge variables associated with path $p_{i,j}$, and an \emph{edge variable path} $\tilde{e}_{i,j}$ the subset of edge variables in $\tilde{p}_{i,j}$.

Timing considerations play a key part in the specifications for an electric
power system. LTL, however, only addresses the notion of temporal ordering of
events. To reconcile this discrepancy, we handle timing annotations 
by introducing clock variables. 

Based on the set of variables above, patterns are used to generate a
contract $\pfr{C} = (A, G)$, where assumptions $A$ encode the allowable
behaviors of the environment the control system operates in, and guarantees
$G$ encode the controller requirements. 

\section{High-Level Patterns}

The ``high-level'' patterns proposed below form a domain-specific language that can be 
used to specify electric power distribution networks. 

\subsection{Environment Assumptions} \label{formalspecsA}

 \subsubsection{[N] failures are allowed for the [\texttt{TYPE}]}

 Let $\mathcal{I}$ be an index set enumerating the set of components (and variables) of type \texttt{TYPE} in $V$, as  described in Section~\ref{sec:variables}, and let $N$ be an integer number larger than zero and smaller than the number of elements $|V|$  in $V$. This pattern provides a
 bound on the number of simultaneous component failures allowed for a certain type. More
 formally, denote a single configuration of the environment (i.e., an
 environment state) by $\mathbf{v}$. For a given subset $\mathcal{I}'\subseteq
 \mathcal{I}$ of environment variables of type \texttt{TYPE} such that $|\mathcal{I}'| \leq N$, we define $\mathbf{v}_{\mathcal{I}'}
 = (v_1, \ldots, v_{|\mathcal{I}|})$, where $v_i=0$ (unhealthy) if
 $i\in\mathcal{I}'$; and $v_i=1$ (healthy) otherwise. We can then enumerate all
allowable environment configurations as
\begin{equation}\label{eq:relassumption}
\mathcal{E} = \left\{ \mathbf{v}_{\mathcal{I}'} | |\mathcal{I}'| \leq N \right\}.
 \end{equation}
With this definitions, an environment assumption can be written in LTL
as $\square (\mathbf{v}\in \mathcal{E}$), requiring that the 
disjunction of all the combinations of environment variable assignments such that all but $N$ components (at most) are healthy must hold. Each combination is represented as a conjunction of environment variables. 

\subsubsection{[\texttt{TYPE}] are never failing}

This pattern is a special case of the pattern above with $N=0$, i.e., the conjunction of all the environment variables indexed by $\pfr{I}$ evaluates to 1 at all times. 

\subsubsection{[\texttt{TYPE}] do not recover after failures}

When a component of type \texttt{TYPE} fails, it will not come back online. This can be expressed in LTL as
\begin{equation} \square \bigwedge_{i \in \mathcal{I}} \left( (v_i = 0) \rightarrow \next (v_i = 0) \right). \end{equation}


\subsection{System Guarantees} \label{formalspecsG}

%\textbf{Power Status of Buses:} An AC bus can only be powered if  there exists a \emph{live path} (i.e., all contactors closed along a path) that connects the bus to a healthy AC generator or a healthy APU. Similarly, a DC bus can only be powered if  there exists a live path that connects it to a healthy rectifier unit, which itself is connected to a powered AC bus. Let $\tilde{p}_{i,B}$ denote the set of all components (i.e., contactors and buses) along a path between bus $B$ and environment variable $e_i$ for $i \in \mathcal{I}$, excluding $B$ and $e_i$. Furthermore, let $\mathcal{G} \subseteq \mathcal{I}$ and $\mathcal{R} \subseteq \mathcal{I}$ represent the sets of generators and rectifier units. AC bus $B$ is powered if there exists a live path between $B$ and $e_i$ for $i \in \mathcal{G}$, written as\footnote{Per abuse of notation, we denote components by uppercase letters (e.g., C, B) and component statuses by lowercase letters (e.g., c, b).}
%  \begin{equation}
%  \square \left\{  \bigvee_{i \in \mathcal{G}} \left(  (e_i = 1) \wedge \bigwedge_{X \in \tilde{p}_{i,B}} (x=1) \right) \rightarrow (b = 1) \right\}.
% \end{equation}
%If there exists no live path between $B$ and a generator $e_i$ for $i \in \mathcal{G}$, then $B$ will be unpowered
% \begin{equation}
% \square \left \{\lnot \bigvee_{i \in \mathcal{G}} \left(  (e_i = 1) \wedge \bigwedge_{X \in \tilde{p}_{i,B}} (x=1)  \right) \rightarrow (b = 0) \right\}.
% \end{equation}
%A similar set of specifications for DC buses holds in which environment variables
%$e_i$ span $i \in \mathcal{R}$.

\subsubsection{[\texttt{TYPE1}] are never connected in parallel through [\texttt{TYPE2}]} 

To avoid paralleling nodes of type \texttt{TYPE1} via nodes of type \texttt{TYPE2}, we explicitly enumerate and disallow all bad configurations. Given the system topology graph $\pfr{G}$, let $\pfr{G}'$ be the undirected sub-graph composed only by nodes of types  \texttt{TYPE1} and \texttt{TYPE2}. 
Paralleling can occur if there exists an \emph{interconnection path} that connects two \texttt{TYPE1} nodes in $\pfr{G}'$. 

<<<<<<< HEAD
Let $\tilde{p}_{i,j}$ represent the set of component (node and edge) variables in  $\pfr{G}'$ along a path between components $V_i, V_j$ of type \texttt{TYPE1}, i.e., $i,j \in \mathcal{I}_1$ and $i \neq j$. 
Let $\tilde{e}_{i,j}$ represent the set of edge variables in $\tilde{p}_{i,j}$. We disallow configurations in which the set of all contactor variables $e \in \tilde{e}_{i,j}$ evaluate to $1$. This pattern can be translated as
%
 \begin{equation} \label{eq:noparallel}
\square \bigwedge_{i,j \in \mathcal{I}_1} \bigwedge_{\tilde{e}_{i,j} \in \mathcal{E}_{i,j}} \left\{ \lnot \bigwedge_{e \in \tilde{e}_{i,j}} ( e = 1) \right\},
 \end{equation}
 %
 where $\mathcal{E}_{i,j}$ is the set of edge variable paths between components $V_i$ and $V_j$ in $\pfr{G}'$.
=======
Let $\tilde{p}_{i,j}$ represent the set of components (nodes and edges) in  $\pfr{G}'$ along a path between components $V_i, V_j$ of type \texttt{TYPE1}, i.e., $i,j \in \mathcal{I}_1$ and $i \neq j$. We disallow configurations in which the set of all contactors $E \in \tilde{p}_{i,j}$ create an interconnection path. This pattern can be translated as\footnote{Per abuse of notation, we denote components by uppercase letters (e.g., E, V) and component statuses by lowercase letters (e.g., e, v).}
%
 \begin{equation} \label{eq:noparallel}
\square \bigwedge_{i,j \in \mathcal{I}_1} \bigwedge_{\tilde{p}_{i,j} \in \mathcal{P}_{i,j}} \left\{ \lnot \bigwedge_{E \in \tilde{p}_{i,j}} ( e = 1) \right\},
 \end{equation}
 %
 where $\mathcal{P}_{i,j}$ is the set of paths between components $V_i$ and $V_j$ in $\pfr{G}'$.
>>>>>>> 8d1e588bcece9421a563a2da85a0ac192a9982d2
 
 \subsubsection{[\texttt{TYPE}] must be disconnected when unhealthy}
 
This pattern requires that appropriate contactors open when a component becomes unhealthy to isolate it  and prevent its use. Let $\mathcal{N}(v_i)$ represent the set of contactors directly connected, or
 neighboring, a component of type \texttt{TYPE} with state variable $v_i$ for $i \in \mathcal{I}$.
 We write the specifications to disconnect all unhealthy components as
 \begin{equation}\label{eq:unhealthysource}
 \square \bigwedge_{i \in \mathcal{I}} \left \{ (v_i = 0) \rightarrow \bigwedge_{E \in \mathcal{N}(v_i)} \next (e = 0)\right \}.
 \end{equation}

\subsubsection{[\texttt{TYPE1}] should be powered by [\texttt{TYPE2}]}

Under nominal conditions (i.e., if at least one component of type \texttt{TYPE2} is healthy), 
for every component of \texttt{TYPE1} there must exists a \emph{live path} to a node of \texttt{TYPE2}. 
Formally, 
% \begin{equation}\label{eq:balanced}
% \square \bigwedge_{i \in \mathcal{I}_1} \bigvee_{\tilde{p}_{i,j} \in \mathcal{P}_i} \left\{ \bigwedge_{C \in \tilde{p}_{i,j}} (c = 1) \right\},
% \end{equation}
%
\begin{equation}\label{eq:balanced}
\square \left\{ \bigvee_{j \in \mathcal{I}_2} (v_j = 1) \rightarrow \bigwedge_{i \in \mathcal{I}_1} \bigvee_{\tilde{p}_{i,j} \in \mathcal{P}_i} \bigwedge_{C \in \tilde{p}_{i,j}} (c = 1) \right\}
 \end{equation}
where $\pfr{P}_i = \{\tilde{p}_{i,j} | j \in \pfr{I}_2\}$.

%the power drawn from each generator by the buses connected to it should be less than the
%capacity of that generator. Let $\tilde{P}_B$ be a constant that corresponds to the
%maximum power required by the loads connected to the bus $B$ and $\tilde{P}_{e_i}$ be a
%constant corresponding to the power generator $i$ can nominally provide. Using
%the live path constructs, we define the power variables $l_{i,B} \in\{0, \tilde{P}_B\}$
%such that $\bigwedge_{X \in \tilde{p}_{i,B}} (x=1) \rightarrow (l_{i,B} = \tilde{P}_B)$, and
%$\lnot \bigwedge_{X \in \tilde{p}_{i,B}} (x=1) \rightarrow (l_{i,B} = 0)$. Then, the
%power flow requirement can be written as
% $$  \square  \left \{ \bigwedge_{i \in \mathcal{I}} (e_i = 1) \rightarrow
% \bigwedge_{i \in \mathcal{G}} (\tilde{P}_{e_i} \geq \sum_{B\in\mathcal{B}}
% l_{i,B})\right \},$$
%where $\pfr{B}$ represents the set of buses.

%\textbf{Safety-Criticality of Buses:} A safety-critical bus can be unpowered for
%no longer than $T_s$ time steps. This is implemented through the use of an
%additional clock variable $x_B$ for each bus B, where each ``tick" of the clock
%represents $\delta$ time. If the bus is unpowered, then at the next time step
%clock $x_B$ increases by $\delta$. If $B$ is unpowered, then at the next time
%step clock $x_B$ resets to zero. Then, we limit the number of steps $B$ can
%remain unpowered in order to ensure that $x_B$ never becomes larger than $T_s$.
%Thus, for all safety-critical buses,
%\begin{subequations}\label{eq:buspower}
%\begin{align}
%\square \left \{ (b=0) \rightarrow (\next x_B = x_B + \delta)\right \}, \\
%\square \left \{ (b=1) \rightarrow (\next x_B = 0) \right \}, \\
%\square (x_B \leq T_s).
%\end{align}
%\end{subequations}

\subsubsection{[\texttt{TYPE1}] must never be disconnected from [\texttt{TYPE2}]}

There must always be an \emph{interconnection path} between every node of \texttt{TYPE1} and any node of \texttt{TYPE2}. Formally, 
 \begin{equation}\label{eq:balanced}
<<<<<<< HEAD
 \square \bigwedge_{i \in \mathcal{I}_1} \bigvee_{\tilde{e}_{i,j} \in \mathcal{E}_i} \bigwedge_{e \in \tilde{e}_{i,j}} (e = 1),
 \end{equation}
where $\pfr{E}_i = \{\tilde{e}_{i,j} | j \in \pfr{I}_2\}$.
=======
 \square \bigwedge_{i \in \mathcal{I}_1} \bigvee_{\tilde{p}_{i,j} \in \mathcal{P}_i} \bigwedge_{E \in \tilde{p}_{i,j}} (e= 1),
 \end{equation}
where $\pfr{P}_i = \{\tilde{p}_{i,j} | j \in \pfr{T}_2\}$.
>>>>>>> 8d1e588bcece9421a563a2da85a0ac192a9982d2

\subsubsection{[\texttt{TYPE1}] must never be unpowered from [\texttt{TYPE2}]}

There must always be a \emph{live path} between every node of \texttt{TYPE1} and any node of \texttt{TYPE2}. Formally, 
 \begin{equation}\label{eq:balanced}
 \square \bigwedge_{i \in \mathcal{I}_1} \bigvee_{\tilde{p}_{i,j} \in \mathcal{P}_i} \bigwedge_{C \in \tilde{p}_{i,j}} (c = 1),
 \end{equation}
where $\pfr{P}_i = \{\tilde{p}_{i,j} | j \in \pfr{I}_2\}$.

The above mentioned specifications can be put in assume-guarantee form as
explained above. Moreover, since they are within the GR(1)
fragment of LTL, digital synthesis tools, such as the one implemented in
JTLV~\cite{jtlv} or \textsc{gr1c}, can be used to automatically check their realizability (a form of 
contract consistency). For the examples released with the first version of CHASE, we used the Temporal Logic Planning
(TuLiP) Toolbox~\cite{noktulip}, a collection of Python-based code for automatic
synthesis of embedded control software, which provides
an interface to JTLV, \textsc{gr1c}, \textsc{Lily}, and \textsc{LTL2BA}.

% \pierluigi{It seems we need to enumerate paths in several formulas above? What is the complexity? Can it become problematic for large topologies?}

\section{Low-Level Patterns}

We list here a set of lower level patterns that are also supported by CHASE. Translation into LTL is straightforward. The square brackets used in the patterns below are then supposed to be filled with variables (signals) or Boolean combinations of variables (signals.) 
\begin{itemize}
%\item \textbf{Initial conditions:} \texttt{env starts with []} sets initial conditions on the system inputs (e.g.,  health status of the generators), while \texttt{system starts with []} sets initial values for the outputs (e.g., status of the contactors).
\item \textbf{Initial conditions:} \texttt{env starts with [T/F]} sets initial conditions on the system inputs (e.g.,  health status of the generators), while \texttt{system starts with [T/F]} sets initial values for the outputs (e.g., status of the contactors).
\item \textbf{Logic and temporal constructs:} 
\begin{itemize} 
\item \texttt{always []} 
\item \texttt{if system sensed [] then do []}
\item \texttt{if system is sensing [] then do []} 
\item \texttt{if system activated [] and sensed [] then do []} 
\item \texttt{do [] if and only if system is sensing []}
\end{itemize}
%\item \textbf{Logic and temporal constructs:} 
%\begin{itemize} 
%\item \texttt{always []} 
%\item \texttt{infinitely often []}
%\item \texttt{if [] then []} 
%\item \texttt{[] unless []} 
%\item \texttt{[] if and only if []}
%\end{itemize}
%\item \textbf{Patterns used to trigger transitions due to input/output actions or observations:} 
%\begin{itemize}
%\item \texttt{system senses []} 
%\item \texttt{system does not sense []} 
%\item \texttt{system sensed []} 
%\item \texttt{system did not sense []} 
%\item \texttt{system actuates []}
%\item \texttt{system does not actuate []}
%\item \texttt{system actuated []}
%\item \texttt{system did not actuate []}
%\end{itemize}
%\item \textbf{``Higher-level" behaviors (combinations of previous patterns):} 
%\begin{itemize}
%\item \texttt{[] is set on [] and reset on []}
%\item \texttt{[]  is toggled on []}
%\end{itemize}
\end{itemize}

\pierluigi{Work in progress \ldots}

\section{Capturing Timed Requirements}

\pierluigi{Work in progress \ldots}

\noop{
In the discussion above, we assumed ideal contactors that can be
instantaneously controlled. It is possible to capture delays in contactor
opening and closing times, as well as the communication delays between the
controller and the contactors. To this effect, one can introduce a controlled
variable $\tilde C$ to represent the controller intent for contactor $C$ and
treat the contactor as an environment variable. The uncertain delay between the
controller intent and contactor state can be handled by the use of an additional
clock variable $x_C$ for each contactor $C$, where each ``tick" of the clock
represents $\delta$ time. If the contactor intent is open and the contactor
state is closed, the contactor opens within $[T_{o_{min}}, T_{o_{max}}]$ units
of time unless a close command is issued before it opens. If the contactor
intent is closed and the contactor state is open, the contactor closes within
$[T_{c_{min}},T_{c_{max}}]$ units of time unless an open command is issued
before it closes. Once the contactor intent is set, if the contactor state does not
match the intent, at the next step clock $x_C$ will increase by $\delta$. If
contactor state and intent match, then at the next step clock $x_C$ resets to
zero:
\begin{eqnarray*}
% \always \{  (\tilde c \neq c) \rightarrow (\next x_C = x_C + \delta) \}, \\
\always \{  (\next c = \tilde c ) \rightarrow (\next x_C =0) \}.
\end{eqnarray*}
When the control command is the same as the contactor state, the contactor state
remains the same, i.e.,
\begin{eqnarray*}
\always \{  (\tilde c = c ) \rightarrow (\next c = c) \}.
\end{eqnarray*}
Finally, the assumption capturing the contactor closing behavior in relation to the controller input intent is given by
\begin{eqnarray*}
\always \left \{  (\tilde c = 1 \wedge c =0 \wedge (x_C < T_{c_{min}})  ) \rightarrow \right. \\
\;\; \; \left. (\next c = 0 \wedge \next x_C = x_C + \delta)\right\},\\
\always \left \{  (\tilde c = 1 \wedge c =0 \wedge (x_C \geq T_{c_{min}})  ) \rightarrow \right. \\
\;\; \; \left. (\next c = 1 \vee \next x_C = x_C + \delta)\right\},\\
\always ( x_C \leq T_{c_{max}}).
\end{eqnarray*}
The contactor opening behavior can be formally captured in a similar manner.
The formulas mentioned in this section enter to the control synthesis problem as
new environment assumptions when delays are taken into account.
It should also be noted that unhealthy sources can only be disconnected with a
delay in this case, therefore formula \eqref{eq:unhealthysource} should be
adjusted accordingly.
}

% \section{Domain-Specific Language}

% The component
% properties that are used to formulate the LTL specifications are
% directly referenced from the component attributes in the platform library, as
% described in \secref{models}. Given the electric power system topology and the
% component attributes, the LTL specifications in \secref{example} can be
% converted from a set of primitives, a representative subset of which are
% provided in the following.

%\textbf{Environment assumptions:} In the environment primitive, the first input
%is the system reliability level, followed by all subsets of components that are
%uncontrolled and can fail. As an example, when only generators and rectifier
%units are assumed to fail, this can be written as $
%\textbf{env}(r_S,\mathcal{G}_e, \mathcal{R}_e)$, where $\mathcal{G}_e \subseteq
%\mathcal{G}$ and $\mathcal{R}_e \subseteq \mathcal{R}$, $\mathcal{G}$ and
%$\mathcal{R}$ being the sets of all generators and rectifier units,
%respectively.
%
%\textbf{No-paralleling of AC sources:} A ``non-paralleling'' primitive accepts as
%inputs any subset of $\mathcal{G}$, and can be written as
%$\textbf{noparallel}(\mathcal{G}_p),$ where $\mathcal{G}_p \subseteq
%\mathcal{G}$.
%
%\textbf{Essential (safety-critical) buses:} Let the set of all buses be
%$\mathcal{B}$. An ``essential bus'' primitive can input any subset of $\mathcal{B}$
%such that the bus elements can be unpowered for no longer than the maximum
%allowable time as specified in the component library. This primitive is written
%as $\textbf{essbus}(\mathcal{B}_e),$ where $\mathcal{B}_e \subseteq
%\mathcal{B}$.

% \textbf{DC buses:} DC buses must always remain powered. For DC buses
% $\mathcal{B}_{DC} \in \mathcal{B}$, the primitive may be written \\
% $\textbf{buspower}(\mathcal{B}_{DC})$.

\noop{
\textbf{Disconnect unhealthy sources:} A ``disconnect'' primitive can take as input the
union of subsets of $\mathcal{G}$ and $\mathcal{R}$. This primitive is written
as $\textbf{disconnect}(\mathcal{G}_d, \mathcal{R}_d),$ where $\mathcal{G}_d
\subseteq \mathcal{G}$ and $\mathcal{R}_d \subseteq \mathcal{R}$.
}


\section{Conclusions}
\seclabel{conclusions}

This first draft presented an initial list of the patterns currently supported in CHASE and their translation in linear temporal logic. We will continue updating the draft in the future.  

\section{Acknowledgments}
This work was supported in part by IBM and UTC via
the iCyPhy consortium and by the TerraSwarm Research Center, one of six centers
supported by the STARnet phase of the Focus Center Research Program (FCRP) a
Semiconductor Research Corporation program sponsored by MARCO and DARPA.

\bibliographystyle{IEEEtran}
% \bibliography{Contracts-CPS,AnalogPlatforms,Synthesis}
\bibliography{chase-doc}

\end{document}

%APPENDICES are optional
%\balancecolumns
% \appendix
% Appendix A
% \section{Headings in Appendices}
% \subsection{Introduction}
% \subsection{The Body of the Paper}
% \subsubsection{Type Changes and  Special Characters}
% \subsubsection{Math Equations}
% \paragraph{Inline (In-text) Equations}
% \paragraph{Display Equations}
% \subsubsection{Citations}
% \subsubsection{Tables}
% \subsubsection{Figures}
% \subsubsection{Theorem-like Constructs}
% \subsubsection*{A Caveat for the \TeX\ Expert}
% \subsection{Conclusions}
% \subsection{Acknowledgments}
% \subsection{Additional Authors}
% \subsection{References}
% This next section command marks the start of
% Appendix B, and does not continue the present hierarchy
% \balancecolumns
% That's all folks!




